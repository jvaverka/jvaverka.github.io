<?xml version="1.0" encoding="UTF-8"?>

<rss version="2.0"
  xmlns:content="http://purl.org/rss/1.0/modules/content/"
  xmlns:dc="http://purl.org/dc/elements/1.1/"
  xmlns:media="http://search.yahoo.com/mrss/"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:georss="http://www.georss.org/georss">

  <channel>
    <title>
      <![CDATA[  {{fd2rss website_title}}  ]]>
    </title>
    <link> {{website_url}} </link>
    <description>
      <![CDATA[  {{fd2rss website_description}}  ]]>
    </description>
    <atom:link
      href="{{fd_rss_feed_url}}"
      rel="self"
      type="application/rss+xml" />


<item>
  <title>
    <![CDATA[  Investment Science 01  ]]>
  </title>
  <link> https://jvaverka.github.io/notes/invsci-01/index.html </link>
  <guid> https://jvaverka.github.io/notes/invsci-01/index.html </guid>
  <description>
    <![CDATA[  This is a Literate.jl and RSS test.  ]]>
  </description>  
  
  <content:encoded>
    <![CDATA[  <h1 id="investment_science_-_module_1">Investment Science - Module 1</h1>
<div class="franklin-toc"><ol><li>Problem 4<ol><li>Solution</li></ol></li><li>Problem 5<ol><li>Solution</li></ol></li></ol></div>
<h2 id="problem_4">Problem 4</h2>
<p>The IRR is generally calculated using an iterative procedure. Suppose that we define \(f(\lambda) = -a_{1} + a_{2}\lambda^{2} + \ldots + a_{n}\lambda^{n}\), where all \(a_{i}\)&#39;s are positive and \(n > 1\). Here is an iterative technique that generates a sequence \(\lambda_{0}, \lambda_{1}, \lambda_{2}, \ldots \lambda_{k}, \ldots\) of estimates that converges to the root \(\overline{\lambda} > 0\), solving \(f(\overline{\lambda}) = 0\). Start with any \(\lambda_{0} > 0\) close to the solution. Assuming \(\lambda_{k}\) has been calculated, evaluate</p>
\[
f'(\lambda_{k}) = a_{1} + 2a_{2}\lambda_{k} + 3a_{3}\lambda_{k}^{2} + \ldots + na_{n}\lambda_{k}^{n-1}
\]
<p>and define</p>
\[
\lambda_{k+1} = \lambda_{k} - \frac{f(\lambda_{k})}{f'(\lambda_{k})}
\]
<p>This is Newton&#39;s method. It is based on approximating the function \(f\) by a line tangent to its graph at \(\lambda_{k}\). Try the procedure on \(f(\lambda) = -1 + \lambda + \lambda^{2}\). Start with \(\lambda_{0} = 1\) and compute four additional estimates.</p>
<h3 id="solution">Solution</h3>
<p>We know</p>
\[
\begin{aligned}
\lambda_{0} &= 1 \\
\lambda_{k+1} &= \lambda_{k} - \frac{f(\lambda_{k})}{f'(\lambda_{k})} \\
f(\lambda) &= -1 + \lambda + \lambda^{2} \\
f'(\lambda) &= 1 + 2\lambda \\
\end{aligned}
\]
<p>Using all these equations we can compute four additional estimates.</p>
<pre><code class="language-julia"># define function f
f&#40;λ&#41; &#61; -1 &#43; λ &#43; λ^2
# define derivative of f
ḟ&#40;λ&#41; &#61; 1 &#43; 2*λ
# define function to calculate the next λ
next&#40;λ&#41; &#61; λ - f&#40;λ&#41;/ḟ&#40;λ&#41;
# create a list of λs starting with 1
λs &#61; &#91;1.0&#93;
# calculate next four
for n ∈ 1:4
    push&#33;&#40;λs, next&#40;λs&#91;n&#93;&#41;&#41;
end
# display results
@show λs</code></pre><pre><code class="plaintext code-output">λs = [1.0, 0.6666666666666667, 0.6190476190476191, 0.6180344478216818, 0.618033988749989]
</code></pre>
<h2 id="problem_5">Problem 5</h2>
<p>Suppose that you have the opportunity to plant trees that alter can be sold for lumber. This project requires an initial outlay of money in order to purchase and plant the seedlings. No other cash flow occurs until trees are harvested. However, you have a choice as to when to harvest. If you harvest after 1 year, you get your return quickly; but if you wait, the trees will have additional growth and the revenue generated from the sale of the trees will be greater. Assume that the case flow streams associated with these alternatives are:</p>
<ul>
<li><p>Wait \(1\) year: \((-1, 2)\)</p>
</li>
<li><p>Wait \(2\) year: \((-1, ,0, 3)\)</p>
</li>
<li><p>Wait \(3\) year: \((-1, 0, 0, 4)\)</p>
</li>
<li><p>\(\vdots\)</p>
</li>
<li><p>Wait \(n\) year: \((-1, 0, 0, \ldots, n+1)\)</p>
</li>
</ul>
<p>The prevailing interest rate is 10&#37;. When is the best time to cut the trees?</p>
<h3 id="solution__2">Solution</h3>
<p>Let’s first define a function for calculating the Net Present Value, say on a cash flow stream that looks like \((x_{0}, \ldots, x_{n})\) where \(r\) is the prevailing interest rate and \(k\) is the number of years waited to harvest:</p>
\[
NPV = -x_{0} + \frac{x_{k}}{(1+r)^{k}}
\]
<p>We can create a function to calculate the <strong><em>NPV</em></strong> given a <em>cash flow stream</em> and <em>interest rate</em>. Let&#39;s create a table of the first several values to determine the optimal time to harvest.</p>
<pre><code class="language-julia"># define function to calculate net present value
function net_present_value&#40;investment, revenue, year, rate&#41;
    -investment &#43; revenue/&#40;1&#43;rate&#41;^year
end
# define empty array for values
values &#61; &#91;&#93;
# populate some values
for i ∈ 1:20
    append&#33;&#40;values, net_present_value&#40;1, i&#43;1, i, 0.10&#41;&#41;
end
# display some values
@show values</code></pre><pre><code class="plaintext code-output">values = Any[0.8181818181818181, 1.4793388429752063, 2.00525920360631, 2.4150672768253525, 2.72552793835493, 2.95131751037644, 3.1052649458456516, 3.1985664218875973, 3.240976183724846, 3.240976183724846, 3.2059267937767064, 3.142200630234634, 3.055301316313628, 2.9499688145911955, 2.8302727899066134, 2.6996953084325246, 2.5612040402024294, 2.417317008275058, 2.270159816531156, 2.1215161885070124]
</code></pre>
<p>To make reading easier, we can create a table or <code>dataframe</code>.</p>
<pre><code class="language-julia">using DataFrames
df &#61; DataFrame&#40;Dict&#40;:year &#61;&gt; 1:20, :revenue &#61;&gt; values&#41;&#41;
show&#40;df&#41;</code></pre><pre><code class="plaintext code-output">20×2 DataFrame
 Row │ revenue   year
     │ Any       Int64
─────┼─────────────────
   1 │ 0.818182      1
   2 │ 1.47934       2
   3 │ 2.00526       3
   4 │ 2.41507       4
   5 │ 2.72553       5
   6 │ 2.95132       6
   7 │ 3.10526       7
   8 │ 3.19857       8
  ⋮  │    ⋮        ⋮
  14 │ 2.94997      14
  15 │ 2.83027      15
  16 │ 2.6997       16
  17 │ 2.5612       17
  18 │ 2.41732      18
  19 │ 2.27016      19
  20 │ 2.12152      20
         5 rows omitted</code></pre>
<p>A quick glance reveals the maximum revenue.</p>
<pre><code class="language-julia">maximum&#40;values&#41;</code></pre><pre><code class="plaintext code-output">3.240976183724846</code></pre>
<pre><code class="language-julia">using PyPlot;
figure&#40;figsize&#61;&#40;8, 6&#41;&#41;;
plot&#40;df.year, df.revenue&#41;;xlabel&#40;&quot;Year&quot;, fontsize&#61;14&#41;;
ylabel&#40;&quot;Revenue&quot;, fontsize&#61;14&#41;;</code></pre>
<img src="https://jvaverka.github.io/assets/notes/invsci-01/code/output/invsci-01-time-to-harvest.svg" alt="Time to Harvest">
<p>We can see that the graph levels off at the top, and upon inspection of the table we confirm that <strong>years 9 and 10</strong> will yield optimal revenue.</p> ]]>
  </content:encoded>
    
  <pubDate>Sun, 04 Jul 2021 00:00:00 +0000</pubDate>  
  
  
  <atom:author>
    <atom:name>Jacob Vaverka</atom:name>
  </atom:author>
        
</item>
</channel></rss>